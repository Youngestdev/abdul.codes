{"data":{"post":{"id":"44e5235b2350db14fe3aff6a21ea318d","title":"Miniature Realtime Stream","content":"<p>Building Mercury has been fun. I have learned more about software development and MongoDB in particular. For instance, I\nhad never had to make use of MongoDB aggregations until Mercury, and it has been fascinating.</p>\n<p>This little article is just to talk about MongoDB's <code class=\"language-text\">.watch()</code>. In a few words, what the method does is to <em>watch</em> the\nchanges going on in and around a collection. For example, it can log the streams of insert, update, and delete\noperations happening to the selected collection.</p>\n<h2 id=\"okay-what-was-i-building\"><a href=\"#okay-what-was-i-building\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Okay, what was I building?</h2>\n<p>So, I wanted to stream the changes going on in the database and communicate it via a websocket channel to the frontend\nguys. There's an activity tab that should update the user on changes especially as the application is a\nmulti-user-tied-to-one-account application.</p>\n<h2 id=\"so\"><a href=\"#so\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>So...</h2>\n<p>I started by building out the websocket connection manager:</p>\n<div class=\"gridsome-highlight\" data-language=\"py3\"><pre class=\"language-py3\"><code class=\"language-py3\">import asyncio\n\nfrom fastapi import WebSocket\nfrom typing import Dict\nfrom mercury.infra.logger import logger\n\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: Dict[str, WebSocket] = {}\n        self.lock = asyncio.Lock()\n\n    async def connect(self, user_id: str, websocket: WebSocket):\n        await websocket.accept()\n        async with self.lock:\n            self.active_connections[user_id] = websocket\n        logger.info(f&quot;Client {user_id} connected. Active connections: {list(self.active_connections.keys())}&quot;)\n\n    async def disconnect(self, user_id: str):\n        async with self.lock:\n            if user_id in self.active_connections:\n                del self.active_connections[user_id]\n        logger.info(f&quot;Client {user_id} disconnected. Active connections: {list(self.active_connections.keys())}&quot;)\n\n    async def send_to_client(self, user_id: str, message: str):\n        async with self.lock:\n            if user_id in self.active_connections:\n                websocket = self.active_connections[user_id]\n                await websocket.send_text(message)\n                logger.info(f&quot;Message sent to client {user_id}&quot;)\n            else:\n                logger.info(f&quot;No active connection found for user {user_id}&quot;)</code></pre></div>\n<p>It's pretty straightforward. It handles the connection, keeping track and sending back to the designated users.</p>\n<p>Then, the main action - the websocket route. For changes to be listened to, a connection needs to be established for a\nuser. I'm not going to go deep at all, I'm just going to illustrate it. Pardon me, these days, I have become lazy.</p>\n<p>Let's go however. I started by connecting a valid user aka storing the user's credential for subsequent communication:</p>\n<div class=\"gridsome-highlight\" data-language=\"py3\"><pre class=\"language-py3\"><code class=\"language-py3\">if not client_id and not token:\n        await websocket.close(code=1008, reason=&quot;Client ID and token required&quot;)\n        return\n\n    if app.get_client_type_from_client_id(client_id) is None:\n        await websocket.close(code=1000, reason=&quot;Invalid client ID&quot;)\n\n    user = app.authentication_service.decode_jwt(\n        token\n    )\n\n    db = await app.database.get_db()\n\n    valid_user = await db.users.find_one({\n        &quot;email&quot;: user[&quot;user_id&quot;]\n    })\n\n    if valid_user is None:\n        await websocket.close(code=1000, reason=&quot;User does not exist&quot;)\n        return\n\n    await app.websocket.connect(str(valid_user[&quot;_id&quot;]), websocket)</code></pre></div>\n<p>First, I try to ascertain the validity of the client's ID, token and user before proceeding to connect the user, I make\nuse of the ID as it's unique for each of them.</p>\n<h2 id=\"let-the-watch-party-begin\"><a href=\"#let-the-watch-party-begin\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Let the watch party begin</h2>\n<p>In a <code class=\"language-text\">try..except</code> block, I start the main party. I need to be up to date with all the operations but I don't need all\nthe information being passed around as well. Therefore, I wrote an aggregation pipeline to return just the fields I'm\ninterested in:</p>\n<div class=\"gridsome-highlight\" data-language=\"py3\"><pre class=\"language-py3\"><code class=\"language-py3\">pipeline = [\n    {&#39;$match&#39;: {&#39;operationType&#39;: {&#39;$in&#39;: [&#39;insert&#39;, &#39;update&#39;, &#39;delete&#39;]}}},\n    {&quot;$project&quot;: {\n        &quot;operationType&quot;: 1,\n        &quot;documentKey&quot;: 1,\n        &quot;ns&quot;: 1,\n        &quot;fullDocument.creator_id&quot;: 1,\n        &quot;fullDocument.owner._id&quot;: 1,\n        &quot;fullDocument.owned_by&quot;: 1,\n        &quot;fullDocument.quantity_in_stock&quot;: 1,\n        &quot;fullDocument.reorder_point&quot;: 1,\n        &quot;fullDocumentBeforeChange.owned_by&quot;: 1,\n        &quot;fullDocumentBeforeChange.creator_id&quot;: 1\n    }}\n]</code></pre></div>\n<p>In some cases, I need the full document before a change is effected. An example is a delete operation where I need to\nget the document details to update the stream. I defined them in an options dict:</p>\n<div class=\"gridsome-highlight\" data-language=\"py3\"><pre class=\"language-py3\"><code class=\"language-py3\">options = {\n\t\t\t&#39;full_document&#39;: &#39;updateLookup&#39;,\n\t\t\t&#39;full_document_before_change&#39;: &#39;required&#39;\n}</code></pre></div>\n<p>Then I begin the watch operation and store the operation type <code class=\"language-text\">operation_type</code>, document key (ID) <code class=\"language-text\">document_key</code>, and\nthe collection <code class=\"language-text\">collection</code>:</p>\n<div class=\"gridsome-highlight\" data-language=\"py3\"><pre class=\"language-py3\"><code class=\"language-py3\">async with db.watch(pipeline, **options) as change_stream:\n    async for change in change_stream:\n        operation_type = change[&#39;operationType&#39;]\n        document_key = change[&#39;documentKey&#39;][&quot;_id&quot;]\n        collection = change[&quot;ns&quot;][&quot;coll&quot;]</code></pre></div>\n<p>With all these in place, I defined the specific actions to be carried out (mainly websocket broadcast) for each action.\nHere's the one for the <code class=\"language-text\">delete</code> operation:</p>\n<div class=\"gridsome-highlight\" data-language=\"py3\"><pre class=\"language-py3\"><code class=\"language-py3\">        if operation_type == &#39;delete&#39;:\n            full_doc = change.get(&#39;fullDocumentBeforeChange&#39;, {})\n\n            match collection:\n                case &quot;inventory_items&quot;:\n                    business = await db.businesses.find_one({\n                        &quot;_id&quot;: full_doc.get(&quot;owned_by&quot;)\n                    })\n                    recipient = business[&quot;owner&quot;].id if business else None\n                case &quot;orders&quot;:\n                    business = await db.businesses.find_one({\n                        &quot;_id&quot;: full_doc.get(&quot;creator_id&quot;)\n                    })\n                    recipient = business[&quot;owner&quot;].id if business else None\n                case _:\n                    logger.info(f&quot;Unhandled collection for delete: {collection}&quot;)\n                    recipient = None\n\n            if recipient:\n                message = f&quot;Change detected: {operation_type} on document {document_key} in collection {collection}&quot;\n                logger.info(f&quot;Attempting to send message to recipient: {recipient}&quot;)\n                await app.websocket.send_to_client(str(recipient), message)\n            else:\n                logger.info(f&quot;No recipient found for change: {operation_type} in {collection}&quot;)</code></pre></div>\n<p>The action for <code class=\"language-text\">insert</code> and <code class=\"language-text\">update</code> are similar si they're grouped togehter:</p>\n<div class=\"gridsome-highlight\" data-language=\"py3\"><pre class=\"language-py3\"><code class=\"language-py3\">        elif operation_type in [&#39;insert&#39;, &#39;update&#39;]:\n            full_doc = change.get(&#39;fullDocument&#39;, {})\n\n            match collection:\n                case &quot;orders&quot;:\n                    business = await db.businesses.find_one({\n                        &quot;_id&quot;: full_doc.get(&quot;creator_id&quot;)\n                    }, {&quot;owner&quot;: 1})\n                    recipient = business[&quot;owner&quot;].id if business else None\n                case &quot;inventory_items&quot;:\n                    business = await db.businesses.find_one({\n                        &quot;_id&quot;: full_doc.get(&quot;owned_by&quot;)\n                    }, {&quot;owner&quot;: 1})\n                    recipient = business[&quot;owner&quot;].id if business else None\n\n                    if full_doc.get(&quot;quantity_in_stock&quot;) &lt;= full_doc.get(&quot;reorder_point&quot;):\n                        await app.websocket.send_to_client(str(recipient),\n                                                           &quot;Stock low, please restock the inventory to continue issuing orders.&quot;)\n\n                case _:\n                    logger.info(f&quot;Unhandled collection for {operation_type}: {collection}&quot;)\n                    recipient = None\n\n            if recipient:\n                message = f&quot;Change detected: {operation_type} on document {document_key} in collection {collection}&quot;\n                logger.info(f&quot;Attempting to send message to recipient: {recipient}&quot;)\n                await app.websocket.send_to_client(str(recipient), message)\n            else:\n                logger.info(f&quot;No recipient found for change: {operation_type} in {collection}&quot;)\n\n        else:\n            logger.info(f&quot;Unhandled operation type: {operation_type}&quot;)</code></pre></div>\n<p>The end:</p>\n<div class=\"gridsome-highlight\" data-language=\"py3\"><pre class=\"language-py3\"><code class=\"language-py3\">except asyncio.CancelledError:\n        # Handle cancellation gracefully\n        logger.info(&quot;Task was cancelled. Cleaning up...&quot;)\n    except WebSocketDisconnect:\n        await app.websocket.disconnect(str(valid_user[&quot;_id&quot;]))\n        logger.info(f&quot;User {valid_user[&quot;_id&quot;]} is disconnected&quot;)</code></pre></div>\n<p>I connected an active session:</p>\n<div class=\"gridsome-highlight\" data-language=\"console\"><pre class=\"language-console\"><code class=\"language-console\">Client 67a9f47786c624adede7---- connected. Active connections: [&#39;67a9f47786c624adede7----&#39;]</code></pre></div>\n<div class=\"gridsome-highlight\" data-language=\"console\"><pre class=\"language-console\"><code class=\"language-console\">Change detected: delete on document 67aa00fce173bf9d4ba2---- in collection orders</code></pre></div>\n<h2 id=\"if-you-were\"><a href=\"#if-you-were\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>If you were...</h2>\n<p>If you were to build a streaming endpoint like this, how would you approach it?</p>\n","date":"23 March 2025","timeToRead":5,"image":null}},"context":{}}